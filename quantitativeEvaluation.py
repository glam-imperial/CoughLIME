import os
import numpy as np
import librosa
from pathlib import Path
import pandas as pd
import lime_cough
from temporal_decomposition import TemporalDecomposition
from spectral_decomposition import SpectralDecomposition
from loudness_decomposition import LoudnessDecomposition
from loudness_spectral_decomp import LoudnessSpectralDecomposition
import soundfile
import random
import predict_dicova
import sys


def get_explanation(audio, total_components=None, sr=None, decomp_type='temporal', num_samples=64):
    """
    initializes decomposition and explanation objects and generates an explanation instance
    :param audio: np array((n,)) audio for which to generate the eplanation
    :param total_components: int, number of components to be generated (for temporal and spectral decompositions)
    :param sr: int, audio sample rate
    :param num_samples: int, number of neighborhood samples to train the linear classifier
    :param decomp_type: "spectral", "temporal" or "loudness": decomposition type for the audio
        :return: explanation and decomposition objects
    """

    if decomp_type == 'temporal':
        decomposition = TemporalDecomposition(audio, total_components)
    elif decomp_type == 'spectral':
        decomposition = SpectralDecomposition(audio, sr, total_components)
    elif decomp_type == 'loudness':
        decomposition = LoudnessDecomposition(audio, sr)
    elif decomp_type == 'ls':
        decomposition = LoudnessSpectralDecomposition(audio, sr)
    else:
        print("Error: decomposition type not recognized")
        sys.exit()
    explainer = lime_cough.LimeCoughExplainer()
    explanation = explainer.explain_instance(decomposition=decomposition,
                                             classifier_fn=predict_dicova.predict,
                                             labels=[0],
                                             num_samples=num_samples,
                                             batch_size=16,
                                             )
    return explanation, decomposition


def save_mix(explanation, num_components, save_path, decomposition, sample_rate, gen_random=False):
    """
    saves the audio file generated by the explanation with only the num_components most relevant components
    :param explanation: explanation object
    :param num_components: int, num_components to include in the audio file that is generated
    :param save_path: path, to save the explanation audio file
    :param decomposition: decomposition object of original audio file
    :param sample_rate: int, sample rate of original audio file
    :param gen_random: bool, if True: also generates an audio file with num_components random components
    """
    label = list(explanation.local_exp.keys())[0]
    audio, component_indeces = explanation.get_exp_components(label, positive_components=True,
                                                              negative_components=True,
                                                              num_components=num_components,
                                                              return_indeces=True)
    # num components: how many components should model take for explanations
    if save_path[:2] == './':
        path_name_write = save_path
    else:
        path_name_write = f"./quantitative_evaluation/{num_components}_components/explanations/{save_path[:-5]}_e.wav"
    soundfile.write(path_name_write, audio, sample_rate)
    print("Indices", component_indeces)
    if gen_random:
        # random components must also be generated
        random_mask = np.zeros(decomposition.get_number_components(),).astype(bool)
        random_indices = random.sample(range(decomposition.get_number_components()), num_components)
        random_mask[random_indices] = True
        random_audio = decomposition.get_components_mask(random_mask)
        path_name_write = f"./quantitative_evaluation/{num_components}_components/random_components/{filename[:-5]}_r.wav"
        soundfile.write(path_name_write, random_audio, sample_rate)


def save_predictions_explanations(components, audio_directory_str, total_components=None, decomp_type='temporal',
                                  num_samples=64):
    """
    main function that initializes the quantitative evaluation for the specified audio files
    :param components: list of integers, contains number of component to test on
    :param audio_directory_str: path to directory that contains the audio files
    :param total_components: int, total number of components the audio is split in during decomposition
                            None for loudness decomposition
    :param decomp_type: decomposition type, can be 'loudness', 'temporal' or 'spectral'
    :param num_samples: int, size of the neighborhood to train the linear classifier
    """
    # for each audio file
    # make directory for the number of components if not exists
    file_names = []
    predictions_entire_file = []
    comp_exp = []
    comp_random = []

    for _ in components:
        comp_exp.append([])
        comp_random.append([])

    # TODO: adapt path
    audio_directory = os.fsencode(audio_directory_str)

    for file in os.listdir(audio_directory):
        filename = os.fsdecode(file)
        print("Starting with... ", filename)
        path_file = f'{audio_directory_str}/{filename}'
        file_names.append(filename)

        # get prediction for whole audio file
        prediction_overall = predict_dicova.predict_single_audio(path_file)
        predictions_entire_file.append(prediction_overall)

        # get explanation
        audio, fs = librosa.load(path_file)
        explanation, decomposition = get_explanation(audio, total_components, sr=fs, decomp_type=decomp_type, num_samples=num_samples)

        # get mixes for top_components and save them, adapt this for loudness decomposition
        if decomp_type != 'loudness':
            for index, num_components in enumerate(components):
                morf, rand = get_predictions(explanation, decomposition, num_components, fs)
                comp_exp[index].append(morf)
                comp_random[index].append(rand)
        elif decomp_type == 'loudness':
            for index, level in enumerate(components):  # components = levels
                total = decomposition.get_number_components()
                to_retrieve = int(np.rint(float(level) * float(total)))
                if to_retrieve == 0:
                    to_retrieve = 1
                morf, rand = get_predictions(explanation, decomposition, to_retrieve, fs)
                comp_exp[index].append(morf)
                comp_random[index].append(rand)
        else:
            print("Error: decomposition type not recognized, aborting")
            sys.exit()

    # create csv "summary" with pandas for every component
    for index, num_components in enumerate(components):
        summary_dict = {'File_name': file_names, 'Prediction_whole_file': predictions_entire_file, 'Prediction_top_comp': comp_exp[index], 'Prediction_random_comp': comp_random[index]}
        summary_df = pd.DataFrame.from_dict(summary_dict)
        path_csv = f"./quantitative_evaluation/{num_components}_summary.csv"
        summary_df.to_csv(path_csv)


def get_predictions(explanation, decomposition, num_components, fs):
    """
    gets the predictions for the num_components most relevant components and the random predictions if necessary
    :param explanation: explanation object
    :param decomposition: decomposition object
    :param num_components: int, number of components for the adapted audio file to predict on
    :param fs: int, sample rate of audio file
    :return: (float, prediction on num_components most relevant components, float, prediction on random components)
    """
    label = list(explanation.local_exp.keys())[0]
    audio, component_indeces = explanation.get_exp_components(label, positive_components=True,
                                                              negative_components=True,
                                                              num_components=num_components,
                                                              return_indeces=True)
    # num components: how many components should model take for explanations
    path_name_write = f"./quantitative_evaluation/current_exp.wav"
    soundfile.write(path_name_write, audio, fs)
    morf = predict_dicova.predict_single_audio(path_name_write)
    # generate random

    random_mask = np.zeros(decomposition.get_number_components(),).astype(bool)
    random_indices = random.sample(range(decomposition.get_number_components()), num_components)
    random_mask[random_indices] = True
    random_audio = decomposition.get_components_mask(random_mask)
    path_name_write = f"./quantitative_evaluation/current_rand.wav"
    soundfile.write(path_name_write, random_audio, fs)
    rand = predict_dicova.predict_single_audio(path_name_write)
    return morf, rand


def evaluate_data(components, run=0):
    """
    function to generate and the summary files of the conducted evaluation
    :param components: list of ints, contains the different numbers of components that were tested
    :param run: which run of the significance test to evaluate
    """
    for num_components in components:
        path_df = f"./quantitative_evaluation/{num_components}_summary.csv"
        df = pd.read_csv(path_df)
        data_array = df.to_numpy()
        shape_data = np.shape(data_array)
        number_data = 0
        true_exp = 0
        true_rand = 0
        for i in range(shape_data[0]):
            number_data += 1
            prediction_whole = np.rint(data_array[i, 2])
            prediction_exp = np.rint(data_array[i, 3])
            prediction_rand = np.rint(data_array[i, 4])
            if prediction_whole == prediction_exp:
                true_exp += 1
            if prediction_whole == prediction_rand:
                true_rand += 1

        # save these to txt file for further processing
        print("Number of samples", number_data)
        print("Number of true explanations", true_exp)
        print("Number of true random component predictions", true_rand)
        percentage_true_exp = float(true_exp) / float(number_data)
        percentage_rand = float(true_rand) / float(number_data)
        print("Percentage of true explanations", percentage_true_exp)
        print("Percentage of random true predictions", percentage_rand)
        path_save_summary = f"./quantitative_evaluation/{num_components}_components.txt"
        with open(path_save_summary, 'w') as summary:
            summary.write(f"Number samples: {number_data}")
            summary.write("\n")
            summary.write(f"Number true explanations: {true_exp}")
            summary.write("\n")
            summary.write(f"Number true random predictions: {true_rand}")
            summary.write("\n")
            summary.write(f"Percentage of true explanations: {percentage_true_exp}")
            summary.write("\n")
            summary.write(f"Percentage of random true predictions: {percentage_rand}")


def perform_quantitative_analysis(audio_dir, components=None, total_components=None, decomp='temporal'):
    """
    wrapper function that initiates the evaluation
    :param audio_dir: path to the directory containing the audio files
    :param components: list of ints, differentnumber of components to evaluate
    :param total_components: int, total number of components to generate in the decomposition
                            None for loudness decomposition
    :param decomp: string, type of decomposition, can be 'spectral', 'loudness' or 'temporal'
    """
    new_directory_name = './quantitative_evaluation'
    Path(new_directory_name).mkdir(parents=True, exist_ok=True)
    new_directory_name = f'./quantitative_evaluation/output_run_0'
    Path(new_directory_name).mkdir(parents=True, exist_ok=True)
    if decomp != 'loudness':
        if components is None:
            print("Error: please specify components, aborting")
            sys.exit()
        save_predictions_explanations(components, audio_directory_str=audio_dir, total_components=total_components, decomp_type=decomp)
        evaluate_data(components)
    elif decomp == 'loudness':
        levels = [0.1, 0.25, 0.5, 0.75, 1]
        save_predictions_explanations(levels, audio_directory_str=audio_dir, total_components=None, decomp_type=decomp)
        evaluate_data(levels)
    else:
        print("Error: decomposition type not recognized")
        sys.exit()


def significance_tests(total_runs):
    """
    wrapper function that calls the main evaluation times various times to obtain statistically significant results
    over various runs
    :param total_runs: int, number of runs to perform
    """
    for run in range(total_runs):
        components = [1, 3, 5, 7]
        total_components = 7
        new_directory_name = './quantitative_evaluation'
        Path(new_directory_name).mkdir(parents=True, exist_ok=True)
        save_predictions_explanations(components, total_components)
        new_directory_name = f'./quantitative_evaluation/output_run_{run}'
        Path(new_directory_name).mkdir(parents=True, exist_ok=True)
        evaluate_data(components, run)
